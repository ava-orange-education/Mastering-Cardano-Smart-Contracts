spending multisig

struct Datum {
    required: Int
    amount: Value
    beneficiary: PubKeyHash
    signatures: []PubKeyHash
}
enum Redeemer {
    Sign {
        pkh: PubKeyHash
    }
    Withdraw
}
const ALICE_PKH: PubKeyHash = PubKeyHash::new(#)
const CAROL_PKH: PubKeyHash = PubKeyHash::new(#)

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    tx: Tx = ctx.tx;
    vHash: ValidatorHash = ctx.get_current_validator_hash();
    
    redeemer.switch {
        red: Sign => {
            txOutputContract : []TxOutput = tx.outputs_locked_by(vHash);
            datumData: Data = txOutputContract.head.datum.get_inline_data();
            datumOut: Datum = Datum::from_data(datumData);
            // Each signaure must be signed and then added to the datum
            (tx.is_signed_by(red.pkh)).trace("MSV1: ") &&
            (red.pkh == ALICE_PKH || red.pkh == CAROL_PKH).trace("MSV2: ") &&
            (txOutputContract.head.value == datum.amount).trace("MSV3: ") &&
            (datumOut.signatures.any((pkh: PubKeyHash) 
                                -> Bool {pkh == red.pkh})).trace("MSV4: ")      
        },
        Withdraw => {
            // Confirm required signatures and only allow beneficiary to spend
            (datum.signatures.length == datum.required).trace("MSV5: ") &&
            (tx.is_signed_by(datum.beneficiary)).trace("MSV6: ") 
        }
    }    
}


